# DevLog - July 10, 2025

## Session Overview
Focused on refactoring the building system architecture and beginning transport/logistics system design. Major architectural improvements and performance optimizations completed.

## Completed Work

### Building System Refactoring
**Problem Solved:** Monolithic BuildingInstance class was handling both production and future store logic, making it hard to extend.

**Solution Implemented:**
- Created abstract `BaseBuilding` class for shared functionality
- Refactored `BuildingInstance` -> `ProductionBuilding` with proper inheritance
- Created new `Store` class for store-specific behavior
- Added comprehensive code documentation and comments

**Key Benefits:**
- Clean separation of concerns
- Extensible architecture for future building types
- Professional-quality documentation
- Proper OOP inheritance patterns

### Stock Management System
**Enhanced stock capacity system:**
- Added building-specific storage limits in `BuildingType`
- Implemented capacity checks in production logic
- Different capacities for input vs output storage
- Proper stock validation and overflow prevention

### Performance Optimizations
**Optimized BaseBuilding Update loop:**
- **Before:** `FindObjectOfType<GridManager>()` called every frame (expensive!)
- **After:** Removed GridManager dependency, used fixed cell size
- **Text positioning:** Only updates when building position changes
- **Result:** Significant performance improvement for buildings

### Game Design Documentation
**Updated design documents with:**
- **Resource Management:** Limited money as primary constraint
- **Efficiency Scoring:** 3-star rating system based on cost optimization
- **Player Experience Goals:** Strategic thinking, optimization satisfaction
- **Core Loop:** Store sales -> money -> road building -> efficiency optimization
- **Obstacles:** Bankruptcy risk, terrain costs, route optimization decisions

### Transport System Planning
**Designed demand-driven logistics system:**
- **Philosophy:** Stores create requests when stock drops to 25%
- **Production:** Factories produce until full, only send when requested
- **Capacity:** Different storage limits per building type
- **Stock Flow:** 
  - Stores: Input stock (deliveries) -> Output stock (shelves) -> Customer sales
  - Factories: Input stock (materials) -> Production -> Output stock (finished goods)

**Next Steps Planned:**
- Component-based request system (`BuildingRequestComponent`)
- Modular design: can be added/removed from any building
- Central `TransportManager` for coordination

## Technical Achievements

### Code Quality Improvements
- Comprehensive XML documentation
- Regional code organization (#region blocks)
- Method extraction for better readability
- Single Responsibility Principle applied
- Self-documenting method names

### Architecture Decisions
- Abstract base class pattern for shared building functionality
- Virtual/override methods for customizable behavior
- Component-based approach for transport requests (planned)
- Performance-first optimization mindset

### Files Modified/Created
- `BaseBuilding.cs` - New abstract base class
- `ProductionBuilding.cs` - Refactored from BuildingInstance
- `Store.cs` - New store-specific building class
- `TruckLogistics.md` - Updated with transport request system design
- `CoreLoop.md` - Added efficiency scoring and player experience goals

## Key Learnings
1. **Premature abstraction is bad, but timely refactoring is essential**
2. **Performance optimization should target the biggest bottlenecks first**
3. **Component-based architecture provides excellent flexibility**
4. **Documentation during development saves time later**
5. **Design decisions should be documented for future reference**

## Tomorrow's Priorities
1. Implement `BuildingRequestComponent` for modular request creation
2. Create basic `TransportRequest` class structure
3. Add stock monitoring timers to stores
4. Begin `TransportManager` for request coordination
5. Test the component-based request system

## Session Notes
- Excellent progress on foundational architecture
- Code is now much more maintainable and professional
- Transport system design is solid and ready for implementation
- Performance optimizations show immediate benefits
- Component-based approach will provide great flexibility for different building behaviors

## Continuing Work - Transport System Implementation

### CLAUDE.md Updates
**Added automatic DevLog tracking instruction:**
- Updated CLAUDE.md with requirement to automatically log all development progress
- Updated Building System documentation to reflect new architecture
- Ensures consistent development history tracking

**Starting Transport System Implementation:**
- Ready to begin with TransportRequest class as foundation
- Component-based approach confirmed for BuildingRequestComponent
- Central TransportManager for coordination planned

**Architecture Clarification:**
- TransportRequest = Data class (not component) - holds request information
- BuildingRequestComponent = MonoBehaviour component - creates and manages requests
- TransportManager = MonoBehaviour singleton - coordinates all transport requests

### BuildingRequestComponent Design Decisions
**Smart design insights:**
- **Production-time intervals:** Use building's production time as stock check interval (brilliant!)
- **Input product monitoring:** Buildings only request products they actually need/use
- **Configurable thresholds:** Different buildings can have different stock thresholds
- **Building classification needed:** Add BuildingRole enum to distinguish Producer/Store/Warehouse
- **Naming clarity:** Consider renaming BuildingType class to BuildingTemplate/BuildingData to reduce confusion

### Implementation Progress
**BuildingRole enum and naming updates completed**
- Ready to implement BuildingRequestComponent.cs
- Need to decide: implement TransportRequest data class first, or start with component structure?

**Timer Implementation Discussion:**
- Breaking down stock check timer into manageable parts
- GetCheckInterval() method for production-time vs custom intervals
- Need to clarify CheckStockLevels() logic for different building types

**Stock Checking Logic Clarified:**
- Monitor building's inputProducts list (ProductData array)
- Capacity per product = inputStorageLimit ÷ number of input products
- Example: 100 total capacity, 2 input products = 50 capacity each
- Trigger request when: currentStock <= (capacityPerProduct * threshold)

### BuildingRequestComponent Implementation
**First implementation completed:**
- Timer logic working correctly with production time intervals
- Stock checking loop implemented for all input products
- Threshold calculation logic in place
- **Issues identified:** Calculation order, method naming, missing transport request creation
- **Next:** Fix calculation logic and implement CreateTransportRequest method

**Request Creation Implementation:**
- CreateRequest method implemented with debug logging
- **Issue identified:** Amount calculation using threshold instead of currentStock
- **Correct calculation:** capacityPerProduct - currentStock (to fill to 100%)
- Ready for testing with building components

**Duplicate Request Prevention:**
- **Issue identified:** Component will spam requests every interval until delivery arrives
- **Need solution:** Track pending requests to prevent duplicates
- **Options:** Pending request dictionary, cooldown timers, or exact threshold checking
- **Preferred:** Dictionary to track which products have pending requests

**Implementation Attempt:**
- Added `Dictionary<ProductData, int> deliveringProducts` to track pending deliveries
- **Issue identified:** Duplicate check happens after CreateRequest call, still causes debug spam
- **Learning moment:** Where should the duplicate prevention check occur?
- **Next:** Move check to CheckProductStock and add delivery completion handler

**Duplicate Prevention Fixed:**
- Moved ContainsKey check to CheckProductStock - prevents duplicate requests correctly
- **New challenge:** When/how to remove completed requests from deliveringProducts dictionary
- **Options:** Hook into AddInputStock, monitor stock increases, or event system
- **Most direct:** Callback from BaseBuilding.AddInputStock to notify completion

**Event System Implementation:**
- Chose C# Action approach for clean event handling
- BuildingRequestComponent subscribes to OnProductDelivered event in Start()
- OnDeliveryReceived method removes completed requests from dictionary
- **Complete solution:** Prevents duplicates + automatically cleans up on delivery
- **Next:** Add event declaration and invoke to BaseBuilding.AddInputStock method

**System Conflict Identified:**
- Old experimental delivery system (10-second intervals) conflicts with new request system
- Experimental system keeps filling stock, preventing request triggers
- **Options:** Disable experimental flag, remove experimental code, or modify for compatibility
- **Decision needed:** Keep experimental system for testing or transition fully to request-based system

**Experimental System Disabled:**
- Old delivery system turned off to prevent conflicts
- **Next simulation goal:** Truck delivery with 10-second transport time
- **Flow:** Request created → 10s delivery simulation → AddInputStock → Request cleared
- **Implementation options:** Coroutine in CreateRequest, separate TransportManager, or dedicated delivery simulation
- **Question:** Where should the 10-second delivery simulation logic live?

**Real System Architecture Discussion:**
- **Full system:** Store request → TransportManager → Truck assignment → Pickup → Delivery → Completion
- **Development phases:** Phase 1 (simple simulation), Phase 2 (TransportManager), Phase 3 (visual trucks & pathfinding)
- **Current decision:** Choose between simple coroutine simulation vs. basic TransportManager implementation
- **Learning focus:** What approach best serves learning goals while building functional system

**Major Game Design Decision - Transport Control:**
- **Option 1:** Manual assignment (Cities Skylines bus lines style) - player directly assigns trucks to routes
- **Option 2:** Automatic system (factory style) - system automatically fulfills requests, player manages fleet
- **Mobile considerations:** Manual = high strategy but complex UI, Automatic = mobile-friendly but less direct control
- **Key question:** Route planning strategy vs. fleet optimization strategy - which creates better mobile gameplay?
- **Hybrid possibility:** Automatic with priority settings or route preferences

**Design Direction Confirmed:**
- **Inspiration:** Mini Metro/Mini Motorways simple, elegant mobile design
- **Decision:** Automatic system - player builds infrastructure, system handles vehicles
- **Player manages:** Road layout, building placement, truck upgrades (global)
- **System manages:** Truck routing, request fulfillment, delivery execution
- **Game focus:** Layout optimization and efficiency, not vehicle micromanagement
- **Perfect for mobile:** Simple to understand, strategic depth through optimization

**Game Design Documentation Updated:**
- Updated TruckLogistics.md to reflect automatic transport system design
- Clear separation of player responsibilities (infrastructure) vs system responsibilities (execution)
- Documented Mini Metro/Mini Motorways inspiration and mobile-first approach
- Established global fleet concept and strategic depth through optimization
- **Next:** Implement basic TransportManager following this automatic system design

---
*Session Duration: ~3+ hours (ongoing)*  
*Focus: Architecture & Design -> Transport System Implementation*  
*Next: TransportRequest.cs implementation*